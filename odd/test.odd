class Result ->
	overt var boo this.ok,
	mby<str> this.type,
	mby<idk> this.value,
	mby<str> this.error;
// TODO: Syntax highlighting of "is" clause
//	doesn't fully work.
// TODO: T<X<Y>> will error because
//	">>" is lexed as one operator...
// TODO: what does overt var mean?
//	What is the difference between just var?
//	What is the difference between readonly

// enum Result.types = [
// 	token,
// 	sequence,
// 	some,
// 	maybe
// ];
// TODO: enum rule and tokenisation.
//	Right now it's just a type annotation.

fun Result.success (str type, idk value) ->
	Result(
		ok: true,
		type: type,
		value: [value].flatten());

fun Result.fail (str reason) ->
	Result(
		ok: false,
		error: reason);

fun item (str expected, f check) ->
	Token[] tokens ->
		Result.success(
			type: Result.types.token,
			value: token)
				if check(token)
				else Result.fail`Expected $expected but got $token.`
			where
				Token token = tokens.peek();

fun lexeme (str lexeme) ->
	item(
		expected: lexeme,
		check: Token token -> token.lexeme == lexeme);

class Token ->
	readonly str this.type,
	readonly str this.lexeme;

[Token(
	lexeme: `a`,
	type: `letter`)]
	| lexeme`a`
	| print;