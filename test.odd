//function str: test (bool: doStuff) { return Boolean(Math.random(1, 2)) }
define str: a = some.very.intriquite.lexeme;
define [[num]]: numArr = [[1], [1, 2], [1, 2, 3]];
define iife any: doSomething (arg) {
	return arg * 3 - 1;
}
#if a then b;

iife type: functionName (parameter) {
	return parameter ^ 2;
}

const b = a;
const c = weirdArray;

const obj: objectje = [
  a = 1;
];

//Use : to call the value before it as the first argument to the function after it.
class guy {}
function isNewable (value) {
	return (value instanceof Class);
}
print(guy:isNewable()::invert());

//Possible advanced feature
define objectje.b = c;

#if 1 != 2 {
  //Do nothing
}

class Vector2 {
	add (Vector2: other) {
		//Possible multiple assignment syntaxes
		this[x, y] = other[x, y];
		this.x, this.y = other.x, other.y;
		return this;
	}

	operator + (Vector2: other) {
		return this.add(other);
	}
}

function str: getName () {
  return "Gertje";
}
//Functions don't require the function keyword in quirks mode
str: getName () {
  return "Gertje";
}

const str: gert = /*#run*/ getName();

const ðŸ’© = 13; //This will throw an error if not commented. Might add emoji support later. !!For testing!!

//Test 123
const num: test1 = +.23e2;
const num: test2 = -0.2345433;
const num: test3 = -101.2345e433;

//Support functions
const str: test4 = String(233546);
const num: test5 = Number("233546");
const str: test6 = String();
const boo: test7 = Boolean("1");
Array();
Object();
Function();

repeat 3 {
	//Do nothing
}

if (a == 3 and 4 or 4) then i = 0;
if (test7 exists) then throw new Error();
if (test8 exists) then throw new Error();
if (new Error() instanceof Error) then continue;
switch (1) {
	case 1 {
		//Do nothing
	}
	default {
		continue;
	}
}
break;

#i = 0;
#while (i++ < 10) {
	do nothing.
}
#function test (1, 2, 3) {
	//
}

template name {
	//asd
}

true;
false;
nil;
null;
undefined;

type col {
	return (this[0] === "#") & (this.length > 1);
}

function eat () {
	defer return character.value;
	cursor.step();
}

class Person (obj: options) {
	using options; //Import options namespace.
	overt local str: name = name | "A person";

	//Only assign if exists in the current scope/namespace.
	overt local int: age ?= age;
	overt local col: hairColour ?= hairColour;
	local vec2: position = new vec2(0, 0);

	overt greet (str: greeting) {
		print(`${name} says ${greeting}!`);
	}

	update (boo: spacePressed) {
		using this.position;
		y += ~~spacePressed;
	}
}

const peter = new Person([
	name = "Peter",
	age = 21,
	hairColour = 0xF99999
]);

const [Person]: people = [peter, new Person(), new Person()];

for (person in people) {
	person.greet("hi");
}

const stream = fs.read("file/name.ext");
when stream emits "error", (error: error) => {
	throw error;
}
when stream emits "data", (blob: data) => {
	print(data);
}
when stream emits "end", () => {
	stream.destroy();
}

{
	using stream;
	emit "end";
}

/* test
	block
	comment
*/