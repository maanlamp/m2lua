//function str: test (bool: doStuff) { return Boolean(Math.random(1, 2)) }
define str: a = some.very.intriquite.lexeme;
define arr<arr<num>>: weirdArrayðŸ˜‚ = [[1], [1, 2], [1, 2, 3]];

const b = a;
const c = weirdArray;

const obj: objectje = [
  a = 1;
];
//Possible advanced feature
// define objectje.b = c;

// #if 1 != 2 {
//   //Do nothing
// }

//Functions don't require the function keyword in quirks mode
function str: getName () {
  return "Gertje";
}

const str: gert = /*#run*/ getName();

// const ðŸ˜‚ = 13; //This will throw an error if not commented. Might add emoji support later. !!For testing!!

//Test 123
const num: test1 = +.23e2;
const num: test2 = -0.2345433;
const num: test3 = -101.2345e433;

//Support functions
const str: test4 = String(233546);
const num: test5 = Number("233546");
const str: test6 = String();
const bool: test7 = Boolean(1);
Array();
Object();
Function();

if (a == 3 and 4 or 4) then i = 0;
if (test7 exists) then throw new Error();
if (test8 exists) then throw new Error();
if (new Error() instanceof Error) then continue;
switch (1) {
	case 1 {
		//Do nothing
	}
	default {
		continue;
	}
}
break;

// #i = 0;
// #while (i++ < 10) {
// 	do nothing.
// }

interface name {
	//asd
}

true;
false;
nil;
null;
undefined;

type col {
	return (this[0] === "#") & (this.length > 1);
}

function eat () {
	defer return character.value;
	cursor.step();
}

class Person (obj: options) {
	using options; //Import options namespace.
	overt local str: name = name | "A person";

	//Only assign if exists in the current scope/namespace.
	overt local int: age ?= age;
	overt local col: hairColour ?= hairColour;
	local vec2: position = new vec2(0, 0);

	overt greet (str: greeting) {
		print(`${name} says ${greeting}!`);
	}

	update (boo: spacePressed) {
		using this.position;
		y += ~~spacePressed;
	}
}

const peter = new Person([
	name = "Peter",
	age = 21,
	hairColour = 0xF99999
]);

const [Person]: people = [peter, new Person(), new Person()];

for (person in people) {
	person.greet("hi");
}

const stream = fs.read("file/name.ext");
when stream emits "error", (error: error) => {
	throw error;
}
when stream emits "data", (blob: data) => {
	print(data);
}
when stream emits "end", () => {
	stream.destroy();
}

{
	using stream;
	emit "end";
}

/* test
	block
	comment
*/