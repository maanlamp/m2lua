;; Generic types?
New-List a :: List of a;
;; or
New-List a :: List a;
;; or
New-List a :: a[];


;; Lists?
Chars :: List Char;
;; or
Chars :: Char[];

;; Maybe types?
Result :: Maybe String;
;; or
Result :: String?;

;; Aliases?
;; They would be problematic for solutions like
;; https://www.youtube.com/watch?v=Up7LcbGZFuo
;; and
;; https://lexi-lambda.github.io/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/
String-50 :: String;
;; This would be not a String alias, but rather a
;; specialised instance of String.
;; Or should we provide a special type to signify
;; a unique semantic meaning for another type?
String-50 :: Special String;
;; or
String-50 :: Symbol String;
;; or a more keyword inspired approach?
String-50 :: Extends String;

;; String interpolation?
`2 + 2 = \{2 + 2}`;

LT = -1;
EQ = 0;
GT = 1;
Ordering :: LT | GT | EQ;

;; Typeclasses?
Order (Comparable a) :: {
	;; Methods?
	compare a a :: Ordering;
	;; or
	max :: a -> a -> a,
	min :: a -> a -> a,
	;; Note that the constraint (Eq a) for the typeclass itself
	;; limits all possible types of parameters to that type.
	;; `x` and `y` _must_ therefore be a member of Eq.
	;; Furthermore, constraints on method parameters are
	;; prohibited.

	;; Operator members?
	< :: a -> a -> Boolean,
	<= :: a -> a -> Boolean,
	>= :: a -> a -> Boolean,
	> :: a -> a -> Boolean,
	;; or
	a < a :: Boolean,
	a <= a :: Boolean,
	a >= a :: Boolean,
	a > a :: Boolean,
};

;; Destructuring?
obj = { a = 1, b = 2 };
obj' = { ...obj }; ;; { a = 1, b = 2 }
fields { ...xs } = xs;
fields obj; ;; [[`a`, 1], [`b`, 2]];

;; Ranges?
alphabet = `a`..`z`;
range (Integer x) (Integer y) = x..y;
table-of-two = [2, 4, ...];
;; `...` in this context means to check the difference `x`
;; between the preceeding two values and then
;; continue the list from 3 * x to n * x;

;; List comprehensions?
capitals = [ for letter of alphabet -> uppercase letter ]
;; which of course can be shortened as
capitals' = map uppercase alphabet;
;; but what about deep structures?
all-letters = [
	...(map uppercase alphabet),
	...alphabet,
	;; vs
	for letter of alphabet -> uppercase letter,
	for letter of alphabet -> letter
];
;; or should we just make concat easy?
all-letters' = alphabet + map uppercase alphabet;